---
title: 排序算法（转载）
date: 2004-09-21 06:03:00
tags: 
categories: 
---
# 算法 ALGORITHM

|

算法是程序设计的精髓，程序设计的实质就是构造解决问题的算法，将其解释为计算机语言。

在这里您可以了解到：

  * [算法定义](http://algorithm.myrice.com/algorithm/defination.htm)
  * [伪代码的使用](http://algorithm.myrice.com/algorithm/pseudocode.htm)
  * [算法的复杂性](http://algorithm.myrice.com/algorithm/complexity/index.htm)
  * [算法设计策略 ](http://algorithm.myrice.com/algorithm/technique/index.htm)
  * [常用算法](http://algorithm.myrice.com/algorithm/commonalg/index.htm)

这里所有的算法都以一种类似Pascal语言的伪代码描述，请参阅[伪代码的使用](http://algorithm.myrice.com/algorithm/pseudocode.htm)。  
  
---|---  
  


|

   **新增内容**  
  
---|---  
  


[关于数论的算法----
数论基本知识](http://algorithm.myrice.com/algorithm/commonalg/numberic/basic_knowledge.htm)（May
6, 2001）  
[动态规划重新整理
](http://algorithm.myrice.com/algorithm/technique/dynamic_programming/index.htm)（January
15, 2001）  
[图的深度优先遍历
](http://algorithm.myrice.com/algorithm/commonalg/graph/traversal/dfs.htm)（January
21, 2001）

|

[图的广度优先遍历](http://algorithm.myrice.com/algorithm/commonalg/graph/traversal/bfs.htm)
（January 21, 2001）  
[图的拓扑排序
](http://algorithm.myrice.com/algorithm/commonalg/graph/connectivity/topo_sort.htm)（January
21, 2001）  
  
---|---  
  
# 算法 Algorithm

**算法**
是在有限步骤内求解某一问题所使用的一组定义明确的规则。通俗点说，就是计算机解题的过程。在这个过程中，无论是形成解题思路还是编写程序，都是在实施某种算法。前者是推理实现的算法，后者是操作实现的算法。

一个算法应该具有以下五个重要的特征：

1.      **有穷性：** 一个算法必须保证执行有限步之后结束；

2.      **确切性：** 算法的每一步骤必须有确切的定义；

3.      **输入：** 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件；

4.      **输出：** 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；

5.      **可行性：** 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。

|

**Did you know**  
  
---|---  
  
##  Algorithm 一词的由来  
  
[](http://www-groups.dcs.st-andrews.ac.uk/%7Ehistory/Mathematicians/Al-
Khwarizmi.html)[](http://www-groups.dcs.st-
andrews.ac.uk/%7Ehistory/Mathematicians/Al-
Khwarizmi.html)Algorithm(算法)一词本身就十分有趣。初看起来，这个词好像是某人打算要写"Logarithm"(对数)一词但却把头四个字母写的前后颠倒了。这个词一直到1957年之前在Webster's
New World
Dictionary(《韦氏新世界词典》)中还未出现，我们只能找到带有它的古代涵义的较老形式的"Algorism"(算术)，指的是用阿拉伯数字进行算术运算的过程。在中世纪时，珠算家用算盘进行计算，而算术家用算术进行计算。中世纪之后，对这个词的起源已经拿不准了，早期的语言学家试图推断它的来历，认为它是从把algiros(费力的)+arithmos(数字)组合起来派生而成的，但另一些人则不同意这种说法，认为这个词是从"喀斯迪尔国王Algor"派生而来的。最后，数学史学家发现了algorism(算术)一词的真实起源：它来源于著名的Persian
Textbook(《波斯教科书》)的作者的名字Abu Ja'far Mohammed ibn Musa al-Khowarizm
（约公元前825年）----从字面上看，这个名字的意思是"Ja'far 的父亲，Mohammed 和 Musa 的儿子，Khowarizm
的本地人"。Khowarizm 是前苏联XИBA(基发) 的小城镇 。Al-Khowarizm 写了著名的书Kitab al jabr w'al-
muqabala (《复原和化简的规则》)；另一个词，"algebra"(代数)，是从他的书的标题引出来的，尽管这本书实际上根本不是讲代数的。

逐渐地，"algorism"的形式和意义就变得面目全非了。如牛津英语字典所说明的，这个词是由于同arithmetic(算术)相混淆而形成的错拼词。由algorism又变成algorithm。一本早期的德文数学词典
Vollstandiges Mathematisches Lexicon (《数学大全辞典》) ，给出了Algorithmus
(算法)一词的如下定义："在这个名称之下，组合了四种类型的算术计算的概念，即加法、乘法、减法、除法"。拉顶短语 _algorithmus
infinitesimalis_ ( 无限小方法) ，在当时就用来表示Leibnitz(莱布尼兹)所发明的以无限小量进行计算的微积分方法。

1950年左右，algorithm一词经常地同欧几里德算法(Euclid's
algorithm)联系在一起。这个算法就是在欧几里德的《几何原本》(Euclid's Elements
,第VII卷，命题i和ii)中所阐述的求两个数的最大公约数的过程(即辗转相除法)。

左上方的图片是Abu Ja'far Mohammed ibn Musa al-Khowarizm的肖像，点击该图片可以看见关于他的更详细的资料。

#  

# 排序  
Sorting

**排序问题**
的输入是一个[线性表](http://algorithm.myrice.com/datastructure/index.html?basic/list/chapter1.htm)，该线性表的元素属于一个偏序集；要求对该线性表的元素做某种重排，使得线性表中除表尾外的每个元素都小于等于（或大于等于）它的后继。

设R为非空集合A上的二元关系，如果R满足 **自反性** (对于每一个x∈A，(x,x)∈R )， **反对称性**
((x,y)∈R∧(y,x)∈R→x=y )和 **传递性** ((x,y)∈R∧(y,x)∈R→(x,z)∈R)，则称R为A上的 **偏序关系**
，记作≤。如果(x,y)∈R，则记作x≤y，读作"x小于等于y"。存在偏序关系的集合A称为 **偏序集** 。

注意，这里的≤不是指数的大小，而是指在偏序关系中的顺序性。x≤y的含义是：按照这个序，x排在y前面。根据不同的偏序定义，≤有不同的解释。例如整除关系是偏序关系≤，3≤6的含义是3整除6。大于或等于关系也是偏序关系，针对这个关系5≤4是指在大于或等于关系中5排在4的前面，也就是说5比4大。

在实际应用中，经常遇到的偏序关系是定义在一个记录类型的数据集合上的。在该记录类型中有一个 **主键**
域key，key域的类型是某一个偏序集，记录的其他域称为卫星数据。比较线性表中的两个元素Li和Lj的大小，实际上是比较Li.key和Lj.key的大小（这种比较当然也是偏序集中的比较）。举例而言，某公司的数据库里记
录了员工的数据，每一项纪录包括姓名，编号，年龄，工资等几个域，如果以编号为key域对员工记录排序，则是将员工记录按照编号排序；如果以工资为key域对员工记录排序，则是将员工记录按照工资高低排序；如果以姓名为key域对员工记录排序，则是以员工姓名的汉语拼音按照字典顺序排序。

关于偏序集的具体概念和应用，请参见离散数学的相关资料。

如果一个排序算法利用输入的线性表在原地重排其中元素，而没有额外的内存开销，这种排序算法叫做 **原地置换排序算法** **(in place sort)**
；如果排序后并不改变表中相同的元素原来的相对位置，那么这种排序算法叫做 **稳定排序算法** **(stable sort)** 。

排序问题一般分为 **内排序** **( internal sorting )** 和 **外排序** **( external sorting )**
两类：

1.      [**内排序**](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/index.htm) ：待排序的表中记录个数较少，整个排序过程中所有的记录都可以保留在内存中；

2.      **外排序** ：待排序的记录个数足够多，以至于他们必须存储在磁带、磁盘上组成外部文件，排序过程中需要多次访问外存。



**内排序**

待排序的表中记录个数较少，整个排序过程中所有的记录都可以保留在内存中，这样的排序叫做内排序。

请参阅：

  * [排序问题的计算复杂性 ](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm)
  * [比较排序算法 ](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter2.htm)

    * [冒泡排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bubble_sort/bubble_sort.htm)
    * [选择排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/selection_sort/selection_sort.htm)
    * [插入排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/insertion_sort/insertion_sort.htm)
    * [快速排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm)
    * 合并排序
    * Shell排序
    * 堆排序
  * [线性时间排序算法 ](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter3.htm)
    * [计数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/counting_sort/counting_sort.htm)
    * [基数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/radix_sort/radix_sort.htm)
    * [桶排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bin_sort/bin_sort.htm)

##  

## 冒泡排序 Bubble Sort

最简单的排序方法是冒泡排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的"气泡"，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个"气泡"序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即"轻"的元素在下面，就交换它们的位置。显然，处理一遍之后，"最轻"的元素就浮到了最高位置；处理二遍之后，"次轻"的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是"最轻"元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。这个算法可实现如下。

    
    
    procedure Bubble_Sort(var L:List);
    
    
    var
    
    
    i,j:position;
    
    
    begin
    
    
    1 for i:=First(L) to Last(L)-1 do
    
    
    2  for j:=First(L) to Last(L)-i do
    
    
    3     if L[j]>L[j+1] then 
    
    
    4           swap(L[j],L[j+1]);   //交换L[j]和L[j+1]
    
    
    end;

上述算法将较大的元素看作较重的气泡，每次最大的元素沉到表尾。其中First(L)和Last(L)分别表示线性表L的第一个元素和最后一个元素的位置，swap(x,y)交换变量x,y的值。上述算法简单地将线性表的位置当作整数用for循环来处理，但实际上线性表可能用链表实现；而且上述算法将线性表元素的值当作其键值进行处理。不过这些并不影响表达该算法的基本思想。今后如果不加说明，所有的算法都用这种简化方式表达。

容易看出该算法总共进行了n(n-1)/2次比较。如果swap过程消耗的时间不多的话，主要时间消耗在比较上，因而时间复杂性为 _O_
(n2)。但是如果元素类型是一个很大的纪录，则Swap过程要消耗大量的时间，因此有必要分析swap执行的次数。

显然算法Bubble_Sort在最坏情况下调用n(n-1)/2次Swap过程。我们假设输入序列的分布是等可能的。考虑互逆的两个输入序列L1=k1,k2,..,kn和L2=kn,kn-1,..,k1。我们知道，如果ki>kj，且ki在表中排在kj前面，则在冒泡法排序时必定要将kj换到ki前面，即kj向前浮的过程中一定要穿过一次ki，这个过程要调用一次Swap。对于任意的两个元素ki和kj，不妨设ki>kj，或者在L1中ki排在kj前面，或者L2在中ki排在kj前面，两者必居其一。因此对于任意的两个元素ki和kj，在对L1和L2排序时，总共需要将这两个元素对调一次。n个元素中任取两个元素有Cn2
种取法，因此对于两个互逆序列进行排序，总共要调用Cn2
=n(n-1)/2次Swap，平均每个序列要调用n(n-1)/4次Swap。那么算法Bubble_Sort调用Swap的平均次数为n(n-1)/4。

可以对冒泡算法作一些改进，如果算法第二行的某次内循环没有进行元素交换，则说明排序工作已经完成，可以退出外循环。可以用一个布尔变量来记录内循环是否进行了记录交换，如果没有则终止外循环。

冒泡法的另一个改进版本是双向扫描冒泡法（Bi-Directional Bubble Sort）。设被排序的表中各元素键值序列为：

483 67 888 50 255 406 134 592 657 745 683

对该序列进行3次扫描后会发现，第3此扫描中最后一次交换的一对纪录是L[4]和L[5]：

50 67 255 134 | 406 483 592 657 683 745 888

显然，第3次扫描(i=3)结束后L[5]以后的序列都已经排好序了，所以下一次扫描不必到达Last(L)-i=11-4=7，即第2行的for
循环j不必到达7，只要到达4-1=3就可以了。按照这种思路，可以来回地进行扫描，即先从头扫到尾，再从尾扫到头。这样就得到双向冒泡排序算法：

    
    
    procedure Bi-Directional_Bubble_Sort(var L:List);
    
    
    var
    
    
    low,up,t,i:position;
    
    
    begin
    
    
    1  low:=First(L);up:=Last(L);
    
    
    2  while up>low do
    
    
        begin
    
    
    3     t:=low;
    
    
    4     for i:=low to up-1 do
    
    
    5       if L[i]>L[i+1] then
    
    
              begin
    
    
    6           swap(L[i],L[i+1]);
    
    
    7           t:=i;
    
    
              end;
    
    
    8     up:=t;
    
    
    9     for i:=up downto low+1 do
    
    
    10      if L[i]< L[i-1] then
    
    
              begin
    
    
    11          swap(L[i],L[i-1]);
    
    
    12          t:=i;
    
    
              end;
    
    
    13    low:=t;   
    
    
        end; 
    
    
    end;

算法利用两个变量low和up记录排序的区域L[low..up]，用变量t
记录最近一次交换纪录的位置，4-7行从前向后扫描，9-12行从后向前扫描，每次扫描以后利用t所记录的最后一次交换记录的位置，并不断地缩小需要排序的区间，直到该区间只剩下一个元素。

直观上来看，双向冒泡法先让重的气泡沉到底下，然后让轻的气泡浮上来，然后再让较大气泡沉下去，让较轻气泡浮上来，依次反复，直到排序结束。

双向冒泡排序法的性能分析比较复杂，目前暂缺，那位朋友知道请[告诉我](mailto:starfish.h@china.com)。

冒泡排序法和双向冒泡排序法是[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)，也是[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)，如果算法Bubble_Sort中第3行的比较条件L[j]>L[j+1]改为L[j]> **=** L[j+1]
，则不再是[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)。

## 选择排序 Selection Sort

选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。

选择排序算法可实现如下。

    
    
    procedure Selection_Sort(var L:List);
    
    
    var
    
    
    i,j,s:position;
    
    
    begin
    
    
    1  for i:=First(L) to Last(L)-1 do
    
    
        begin
    
    
    2       s:=i;
    
    
    3       for j:=i+1 to Last(L) do
    
    
    4         if L[j]< L[s] then 
    
    
    5                s:=j;             //记录L[i..n]中最小元素的位置
    
    
    6       swap(L[i],L[s]);       //交换L[i],L[s]
    
    
          end;  
    
    
    end;

算法Selection_Sort中里面的一个for循环需要进行n-i次比较，所以整个算法需要

次比较。

显而易见，算法Selection_Sort中共调用了n-1次swap过程。选择排序法是一个[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)，也是[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)。

##  

## 插入排序 Insertion Sort

插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i]又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤
L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j]
≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入。

图1 对4个元素进行插入排序

在下面的插入排序算法中，为了写程序方便我们可以引入一个哨兵元素L[0]，它小于L[1..n]中任一记录。所以，我们设元素的类型ElementType中有一个常量-∞，它比可能出现的任何记录都小。如果常量-∞不好事先确定，就必须在决定L[i]是否向前移动之前检查当前位置是否为1，若当前位置已经为1时就应结束第i遍的处理。另一个办法是在第i遍处理开始时，就将L[i]放入L[0]中，这样也可以保证在适当的时候结束第i遍处理。下面的算法中将对当前位置进行判断。

插入排序算法如下：

    
    
    procedure Selection_Sort(var L:List);
    
    
    var
    
    
    i,j:position;
    
    
    v:ElementType;
    
    
    begin
    
    
    1 for i:=First(L)+1 to Last(L) do
    
    
        begin
    
    
    2     v:=L[i];
    
    
    3     j:=i;
    
    
    4     while (j<>First(L))and(L[j-1]< v) do  //循环找到插入点
    
    
            begin
    
    
    5         L[j]:=L[j-1];  //移动元素
    
    
    6         j:=j-1;
    
    
            end;
    
    
    7     L[j]:=v;        //插入元素
    
    
        end;
    
    
    end;

下面考虑算法Insertion_Sort的复杂性。对于确定的i，内while循环的次数为 _O_ (i)，所以整个循环体内执行了∑ _O_ (i)= _O_
(∑i)，其中i从2到n。即比较次数为 _O_
(n2)。如果输入序列是从大到小排列的，那么内while循环次数为i-1次，所以整个循环体执行了∑(i-1)=n(n-1)/2次。由此可知，最坏情况下，Insertion_Sort要比较
_Ω_ (n2)次。

如果元素类型是一个很大的纪录，则算法第5行要消耗大量的时间，因此有必要分析移动元素的次数。经过分析可知，平均情况下第5行要执行n(n-1)/4次，分析方法与[冒泡排序的分析](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bubble_sort/bubble_sort.htm#swap)相同。

如果移动元素要消耗大量的时间，则可以[用链表来实现线性表](http://algorithm.myrice.com/datastructure/index.html?basic/list/chapter3_2.htm)，这样Insertion_Sort可以改写如下(当然前一个算法同样也适用于链表，只不过没下面这个好，但是下面算法这个比较复杂)：

注意：在下面的算法中链表L增加了一个哨兵单元，其中的元素为-∞，即线性表L的第一个元素是L^.next^

    
    
    procedure Selection_Sort_II(var L:PList);
    
    
    var
    
    
    i,j,tmp:Position;
    
    
    begin
    
    
    1  if L^.next=nil then exit; //如果链表L为空则直接退出
    
    
    2  i:=L^.next;  //i指向L的第一个元素，注意，L有一个哨兵元素，因此L^.next^才是L的第一个元素
    
    
    3  while i^.next<>nil do
    
    
         begin
    
    
    4      tmp:=i^.next;  //tmp指向L[i]的下一个位置
    
    
    5      j:=L;
    
    
    6      while (j<>i)and(tmp^.data>=j^.next^.data) do //从前向后找到tmp的位置，tmp应该插在j后面
    
    
    7      j:=j^.next;
    
    
    8      if j<>i then  //j=i说明不需要改变tmp的位置
    
    
             begin                              
    
    
    9          i^.next:=tmp^.next;  //将tmp从i后面摘除
    
    
    10         tmp^.next:=j^.next;  //在j后面插入tmp
    
    
    11         j^.next:=tmp;
    
    
             end
    
    
    12     else i:=i^.next;  //否则i指向下一个元素
    
    
        end;
    
    
    end;

上述改进算法主要是利用链表删除和插入元素方便的特性，对于数组则不适用。

插入排序法是一个[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)，也是一个[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)。插入法虽然在最坏情况下复杂性为 _θ_
(n2)，但是对于小规模输入来说，插入排序法是一个快速的[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)。许多复杂的排序法，在规模较小的情况下，都使用插入排序法来进行排序，比如[快速排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm)和桶排序。

下面是一个Java Applet制作的插入排序演示程序。

** **

**快速排序 Quick Sort**

我们已经知道，[在决策树计算模型下，任何一个基于比较来确定两个元素相对位置的排序算法需要Ω(nlogn)计算时间](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm)。如果我们能设计一个需要
_O_ (n1ogn)时间的排序算法，则在渐近的意义上，这个排序算法就是最优的。许多排序算法都是追求这个目标。

下面介绍快速排序算法，它在平均情况下需要 _O_ (nlogn)时间。这个算法是由C.A.R.Hoare发明的。

**算法的基本思想** ****

快速排序的基本思想是基于[分治策略](http://algorithm.myrice.com/algorithm/technique/divide_and_conquer/index.htm)的。对于输入的子序列L[p..r]，如果规模足够小则直接进行排序，否则分三步处理：

  * 分解(Divide)：将输入的序列L[p..r]划分成两个非空子序列L[p..q]和L[q+1..r]，使L[p..q]中任一元素的值不大于L[q+1..r]中任一元素的值。
  * 递归求解(Conquer)：通过递归调用快速排序算法分别对L[p..q]和L[q+1..r]进行排序。
  * 合并(Merge)：由于对分解出的两个子序列的排序是就地进行的，所以在L[p..q]和L[q+1..r]都排好序后不需要执行任何计算L[p..r]就已排好序。

这个解决流程是符合[分治法的基本步骤](http://algorithm.myrice.com/algorithm/technique/divide_and_conquer/chapter3.htm)的。因此，快速排序法是分治法的经典应用实例之一。

**算法的实现** ****

算法Quick_Sort的实现：

**注意：**
下面的记号L[p..r]代表线性表L从位置p到位置r的元素的集合，但是L并不一定要用数组来实现，可以是用任何一种实现方法（比如说链表），这里L[p..r]只是一种记号。

procedure Quick_Sort(p,r:position;var L:List);

const

e=12;

var

q:position;

begin

1  if r-p<=e then Insertion_Sort(L,p,r)//若L[p..r]足够小则直接对L[p..r]进行插入排序

     else begin

2            q:=partition(p,r,L);//将L[p..r]分解为L[p..q]和L[q+1..r]两部分

3            Quick_Sort(p,q,L);  //递归排序L[p..q]

4            Quick_Sort(q+1,r,L);//递归排序L[q+1..r]  

          end;

end;

对线性表L[1..n]进行排序，只要调用Quick_Sort(1,n,L)就可以了。算法首先判断L[p..r]是否足够小，若足够小则直接对L[p..r]进行排序，Sort可以是任何一种简单的排序法，一般用[插入排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/insertion_sort/insertion_sort.htm)。这是因为，对于较小的表，快速排序中划分和递归的开销使得该算法的效率还不如其它的直接排序法好。至于规模多小才算足够小，并没有一定的标准，因为这跟生成的代码和执行代码的计算机有关，可以采取试验的方法确定这个规模阈值。经验表明，在大多数计算机上，取这个阈值为12较好，也就是说，当r-p<=e=12即L[p..r]的规模不大于12时，直接采用插入排序法对L[p..r]进行排序([参见
_Sorting and Searching Algorithms: A
Cookbook_](http://algorithm.myrice.com/resources/refrence/sorting_and_searching_algorithm_cookbook/s_man.htm))
。当然，比较方便的方法是取该阈值为1，当待排序的表只有一个元素时，根本不用排序(其实还剩两个元素时就已经在Partition函数中排好序了)，只要把第1行的if语句该为if
p=r then exit else ...。这就是通常教科书上看到的快速排序的形式。

**注意：**
算法Quick_Sort中变量q的值一定不能等于r，否则该过程会无限递归下去，永远不能结束。因此下文中在[partition函数](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm#Partition#Partition)里加了限制条件，避免q=r情况的出现。

算法Quick_Sort中调用了一个函数partition，该函数主要实现以下两个功能：

1.     在L[p..r]中选择一个支点元素pivot; 

2.     对L[p..r]中的元素进行整理，使得L[p..q]分为两部分L[p..q]和L[q+1..r]，并且L[p..q]中的每一个元素的值不大于pivot，L[q+1..r]中的每一个元素的值不小于pivot， **但是** **L[p..q]** **和** **L[q+1..r]** **中的元素并不要求排好序** 。

快速排序法改进性能的关键就在于上述的第二个功能，因为该功能并不要求L[p..q]和L[q+1..r]中的元素排好序。

函数partition可以实现如下。以下的实现方法是[原地置换](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-sort)的，当然也有不是原地置换的方法，实现起来较为简单，这里就不介绍了。

function partition(p,r:position;var L:List):position;

var

pivot:ElementType;

i,j:position;

begin

1  pivot:=Select_Pivot(p,r,L); //在L[p..r]中选择一个支点元素pivot

2  i:=p-1;

3  j:=r+1;

4  while true do

     begin

5      repeat j:=j-1 until L[j]<=pivot;  //移动左指针，注意这里不能用while循环

6      repeat i:=i+1 until L[i]>=pivot;  //移动右指针，注意这里不能用while循环

7      if i< j then swap(L[i],L[j])  //交换L[i]和L[j]

8              else if j<>r then return j        //返回j的值作为分割点

9                           else return j-1;     //返回j前一个位置作为分割点

     end;

end;

该算法的实现很精巧。其中，有一些细节需要注意。例如，算法中的位置i和j不会超出A[p..r]的位置界，并且该算法的循环不会出现死循环， **如果将两个**
**repeat** **语句换为** **while** **则要注意当** **L[i]=L[j]=pivot** **且** **i <j**
**时** **i** **和** **j** **的值都不再变化，会出现死循环。**

另外，最后一个if..then..语句很重要，因为如果pivot取的不好，使得Partition结束时j正好等于r，则如前所述，[算法Quick_Sort](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm#algorithm-
quick_sort#algorithm-quick_sort)会无限递归下去；因此必须判断j是否等于r，若j=r则返回j的前驱。

以上算法的一个执行实例如图1所示，其中pivot=L[p]=5：

图1 Partition过程的一个执行实例

Partition对L[p..r]进行划分时，以pivot作为划分的基准，然后分别从左、右两端开始，扩展两个区域L[p..i]和L[j..r]，使得L[p..i]中元素的值小于或等于pivot，而L[j..r]中元素的值大于或等于pivot。初始时i=p-1，且j=i+1，从而这两个区域是空的。在while循环体中，位置j逐渐减小，i逐渐增大，直到L[i]≥pivot≥L[j]。如果这两个不等式是严格的，则L[i]不会是左边区域的元素，而L[j]不会是右边区域的元素。此时若i在j之前，就应该交换L[i]与L[j]的位置，扩展左右两个区域。
while循环重复至i不再j之前时结束。这时L[p..r]己被划分成L[p..q]和L[q+1..r]，且满足L[p..q]中元素的值不大于L[q+1..r]中元素的值。在过程Partition结束时返回划分点q。

寻找支点元素select_pivot有多种实现方法，不同的实现方法会导致快速排序的不同性能。根据[分治法平衡子问题的思想](http://algorithm.myrice.com/algorithm/technique/divide_and_conquer/chapter3.htm#balance)，我们希望支点元素可以使L[p..r]尽量平均地分为两部分，但实际上这是很难做到的。下面我们给出几种寻找pivot的方法。

1.     选择L[p..r]的第一个元素L[p]的值作为pivot；

2.     选择L[p..r]的最后一个元素L[r]的值作为pivot；

3.     选择L[p..r]中间位置的元素L[m]的值作为pivot；

4.     选择L[p..r]的某一个随机位置上的值L[random(r-p)+p]的值作为pivot；

按照第4种方法随机选择pivot的快速排序法又称为 ** _随机化版本的快速排序法_**
，在下面的复杂性分析中我们将看到该方法具有平均情况下最好的性能，在实际应用中该方法的性能也是最好的。

下面是一个快速排序的Java
Applet演示程序，该程序使用第一种pivot选择法，即选L[p]为pivot，因此Partition过程作了一些简化，与我们这里的Partition过程实现方法不同，但功能相同。该程序是针对用数组实现的线性表，用C语言实现的。  
  
---  
  








**线性时间排序算法**

我们已经知道，[通过比较确定两个元素之间相对位置的比较排序算法计算时间复杂性下界为O(nlogn)](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm)，要想改进这个下界，就必须对输入的数据作某些限制。下面介绍的几种排序算法都可以在O(n)时间内对一个线性表进行排序，但是他们要求输入数据满足某种条件。

    * [计数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/counting_sort/counting_sort.htm)
    * [基数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/radix_sort/radix_sort.htm)
    * [桶排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bin_sort/bin_sort.htm)

**计数排序 Counting Sort**

计数排序是一个非[基于比较](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm#compsort)的线性时间排序算法。它对输入的数据有附加的限制条件：

1.      输入的[线性表](http://algorithm.myrice.com/datastructure/index.html?basic/list/chapter1.htm)的元素属于有限偏序集S；

2.      设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k= _O_ (n)。

在这两个条件下，计数排序的复杂性为 _O_ (n)。

计数排序算法的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。

假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k= _O_
(n)，S={S1,S2,..Sk}；则计数排序算法可以描述如下：

1.      扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；

2.      扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。

具体的实现如下。

**注意：**
在以下的讨论中，为了方便，我们假设[线性表是用数组来实现的](http://algorithm.myrice.com/datastructure/basic/list/chapter3_1.htm)，并且假设线性表的元素类型TElement为整型，其值在1..k之间，线性表的长度为n，且k=
_O_ (n)。这些假设对计数排序算法没有实质的影响，但是可以使以下介绍的算法看起来容易理解。

在下面的计数排序算法中，我们假设L为输入的长度为n的线性表，输出的排序结果存放在线性表R中。算法中还用到一个辅助表tmp用于对输入元素进行计数。

Type

TElement=1..k;

TList=array [1..maxlength] of TElement;

TPosition=integer;



procedure Counting_Sort(var L,R:TList);

var

i,j:integer;

tmp:TList;

begin

1 for i:=1 to k do tmp[i]:=0;

2 for j:=1 to n do inc(tmp[L[j]]);

   //执行完上面的循环后，tmp[i]的值是L中等于i的元素的个数

3 for i:=2 to k do tmp[i]:=tmp[i]+tmp[i-1];

   //执行完上面的循环后，tmp[i]的值是L中小于等于i的元素的个数

4 for j:=n downto 1 do  //注意这里的downto保证了排序的稳定性

   begin

5   R[tmp[L[j]]]:=L[j];//L[j]存放在输出数组R的第tmp[L[j]]个位置上

6   dec(tmp[L[j]]); //tmp[L[j]]表示L中剩余的元素中小于等于L[j]的元素的个数

   end;

end;

图1所示的是Counting_Sort作用于一个输入数组L[1..8]上的过程，其中L的每一个元素都是不大于k=6的正整数。

|  
  
---|---  
  
|  
  
|  
  
图1 计数排序算法演示

容易理解，算法的第(l)行是对数组tmp初始化。第(2)行检查每个输入元素。如果输入元素的键值为i，则tmp[i]增1。因此，在第(2)行执行结束后，tmp[i]中存放着值等于i的输入元素个数，i=1,2,..,k。算法的第(3)行，对每个i=1,2,..,i，统计值小于或等于i的输入元素个数。最后在(4)-(8)行中，将每个元素L[j]存放到输出数组R中相应的最终位置上。如果所有n个元素的值都不相同，则共有tmp[L[j]]个元素的键值小于或等于L[j]，而小于L[j]的元素有tmp[L[j]]-1个，因此tmp[L[j]]就是L[j]在输出数组R中的正确位置。当输入元素有相同的值时，每将一个L[j]存放到数组R时，tmp[L[j]]就减1，使下  
个值等于L[j]的元素存放在输出数组R中存放元素L[j]的前一个位置上。

计数排序算法的计算时间复杂性很容易分析。其中，第(1)行需要 _O_ (k)时间；第(2)行需要 _O_ (n)时间，第(3)行需要 _O_
(k)时间；第(4)-(8)行的for循环需要 _O_ (n)时间。这样，整个算法所需的计算间为 _O_ (n+k)。当k= _O_
(n)时，算法的计算时间复杂性为 _O_ (n)。

我们看到，计数排序算法没有用到元素间的比较，它利用元素的实际值来确定它们在输出数组中的位置。因此，计数排序算法不是一个[基于比较的排序算法](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm#compsort)，从而它的计算时间下界不再是Ω(nlogn)。另一方面，计数排序算法之所以能取得线性计算时间的上界是因为对元素的取值范围作了一定限制，即k=
_O_
(n)。如果k=n2,n3,..，就得不到线性时间的上界。此外，我们还看到，由于算法第4行使用了downto语句，经计数排序，输出序列中值相同的元素之间的相对次序与他们在输入序列中的相对次序相同，换句话说，计数排序算法是一个[稳定的排序算法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)，但显然不是[原地置换排序算法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-sort)。

**基数排序 Radix Sort**

基数排序是一种用在老式穿卡机上的算法。一张卡片有80列，每列可在12个位置中的任一处穿孔。排序器可被机械地"程序化"以检查每一迭卡片中的某一列，再根据穿孔的位置将它们分放12个盒子里。这样，操作员就可逐个地把它们收集起来。其中第一个位置穿孔的放在最上面，第二个位置穿孔的其次，等等。

对十进制数字来说，每列中只用到10个位置(另两个位置用于编码非数值字符)。一个d位数占用d个列。因为卡片排序器一次只能查看一个列，要对n张片上的d位数进行排序就要有个排序算法。

直感上，大家可能觉得应该按最重要的一位排序，然后对每个盒子中的数递归地排序，最后把结果合并起来。不幸的是，为排序每一个盒子中的数，10个盒子中的9个必须先放在一边，这个过程产生了许多要加以记录的中间卡片堆。

与人们的直感相反，基数排序是首先按最不重要的一位数字排序来解决卡片排序问题的。同样，把各堆卡片收集成一迭，其中0号盒子中的在1号盒子中的前面，后者又在2号盒子中的前面，等等。然后对整个一迭卡片按次重要位排序，并把结果同样地合并起来。重复这个过程，直到对所有的d位数字都进行了排序。所以，仅需要n遍就可将一迭卡片排好序。图1说明了基数排序作"一迭"7个三位数的过程。第一列为输入，其余各列示出了对各个数位进行逐次排序后表的情形。垂直向上的箭头指示了当前要被加以排序的数位。

图1 基数排序作用于一个由7个3位数组成的表上的过程

关于这个算法很重要的一点就是按位排序要稳定。由卡片排序器所故的排序是稳定的，但操作员在把卡片从盒子里拿出来时不能改变他们的次序，即使某一盒子中所有卡片在给定列上的穿孔位置都相同。

在一台典型的顺序随机存取计算机上，有时采用基数排序来对有多重域关键字的记录进行排序。例如，假设我们想根据三个关键字处、月和日来对日期排序。对这个问题，可以用带有比较函数的排序算法来做。给定两个日期，先比较年份，如果相同，再比较月份，如果再相同，再比较日。这儿我们可以采用另一个方法，即用一种稳定的排序方法对所给信息进行三次排序：先对日，其次对月，再对年。

基数排序的代码是很简单的、下面的过程假设长度为n的数组A中的每个元素都有d位数字，其中第1位是最低的，第d位是最高位。

procedure Radix_Sort(var L:List;d:integer);

var

i:integer;

begin

1  for i:=1 to d do

2     使用一种稳定的排序方法来对数组L按数字i进行排序;

end;

基数排序的正确性可以通过对正在被排序的列进行归纳而加以证明。对本算法时间代价的分析要取决于选择哪种稳定的中间排序算法。当每位数字都界于l到k之间，且k不太大时，可以选择计数排序。对n个d位数的每一遍处理的时间为O(n+k)，共有d遍，故基数排序的总时间为θ(dn+kd)。当d为常数，k=O(n)时，基数排序有线性运行时间。

某些计算机科学家倾向于把一个计算机字中所含位数看成是θ(lgn)。具体一点说，假设共有dlgn位数字，d为正常数。这样，如果待排序的每个数恰能容于一个计算机字内，我们就可以把它视为一个以n为基数的d位数。看一个例子：对一百万个64位数排序。通过把这些数当作是以216为基数的四位数，用基数排序四遍就可完成排序。这与一个典型的O(nlgn)比较排序相比要好得多，后者对每一个参加排序的数约要lgn=20次操作。但有一点不理想，即采用计数排序作为中间稳定排序算法的基数排序版本不能够进行原地置换排序，而很多O(nlgn)比较排序算法却是可以的。因此，当内存比较紧张时，一般来说选择快速排序更合适些。



**桶排序 Bin Sort**

平均情况下桶排序以线性时间运行。像计数排序一样，桶排序也对输入作了某种假设，
因而运行得很快。具体来说，计数排序假设输入是由一个小范围内的整数构成，而桶排序则 假设输入由一个随机过程产生，该过程将元素一致地分布在区间[0，1)上。

桶排序的思想就是把区间[0，1)划分成n个相同大小的子区间，或称桶，然后将n个输入数分布到各个桶中去。因为输入数均匀分布在[0，1)上，所以一般不会有很多数落在
一个桶中的情况。为得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列 出来即可。

在桶排序算法的代码中，假设输入是个含n个元素的数组A，且每个元素满足0≤
A[i]<1。另外还需要一个辅助数组B[O..n-1]来存放链表实现的桶，并假设可以用某种机制来维护这些表。

桶排序的算法如下，其中floor(x)是地板函数，表示不超过x的最大整数。

procedure Bin_Sort(var A:List);

begin

1  n:=length(A);

2  for i:=1 to n do

3    将A[i]插到表B[floor(n*A[i])]中;

4  for i:=0 to n-1 do

5    用插入排序对表B[i]进行排序;

6  将表B[0],B[1],...,B[n-1]按顺序合并;

end;



图1 Bin_Sort的操作

图1演示了桶排序作用于有10个数的输入数组上的操作过程。(a)输入数组A[1..10]。(b)在该算法的第5行后的有序表(桶)数组B[0..9]。桶i中存放了区间[i/10，(i+1)/10]上的值。排序输出由表B[O]、B[1]、...、B[9]的按序并置构成。

要说明这个算法能证确地工作，看两个元素A[i]和A[j]。如果它们落在同一个桶中，则它们在输出序列中有着正确的相对次序，因为它们所在的桶是采用插入排序的。现假设它们落到不同的桶中，设分别为B[i']和B[j']。不失一般性，假设i'<j'。在算法的代码中，当第6行中将B中的表并置起来时，桶B[i']中的元素先于桶B[j']中的元素，因而在输出序列中A[i]先于A[j]。现在要证鰽[i]≤A[j]。假设情况正好相反，我们有：

 i'=floor(n*A[i])≥floor(n*A[j])=j'

得矛盾 (因为i'<j')，从而证明桶排序能正确地工作。

现在来分析算法的运行时间。除第5行外，所有各行在最坏情况的时间都是O(n)。第5行中检查所有桶的时间是O(n)。分析中唯一有趣的部分就在于第5行中插人排序所花的时间。

为分析插人排序的时间代价，设ni为表示桶B[i]中元素个数的随机变量。因为插入排序以二次时间运行，故为排序桶B[i]中元素的期望时间为E[O(ni2)]=O(E[ni2])，对各个桶中的所有元素排序的总期望时间为：

(1)

为了求这个和式，要确定每个随机变量ni的分布。我们共有n个元素，n个桶。某个元素落到桶B[i]的概率为l/n，因为每个桶对应于区间[0，1)的l/n。这种情况与投球的例子很类似：有n个球
(元素)和n个盒子
(桶)，每次投球都是独立的，且以概率p=1/n落到任一桶中。这样，ni=k的概率就服从二项分布B(k;n,p)，其期望值为E[ni]=np=1，方差V[ni]=np(1-p)=1-1/n。对任意随机变量X，有:

(2)

将这个界用到(1)式上，得出桶排序中的插人排序的期望运行时间为O(n)。因而，整个桶排序的期望运行时间就是线性的。

下面的Java Applet程序演示了桶排序的基本思想。

很抱歉，您的浏览器不支持Java Applet或者没有打开Java Applet支持。

在该演示程序中，线性表的元素类型为整型，桶的标号为整数，算法将值为i的元素放入标号为i的桶中，再按照桶的标号的顺序将元素依次取出，就得到了最终的排序结果。



---
title: 排序算法（转载）
date: 2004-09-21 06:03:00
tags: 
categories: 
---
# 算法 ALGORITHM

|

算法是程序设计的精髓，程序设计的实质就是构造解决问题的算法，将其解释为计算机语言。

在这里您可以了解到：

  * [算法定义](http://algorithm.myrice.com/algorithm/defination.htm)
  * [伪代码的使用](http://algorithm.myrice.com/algorithm/pseudocode.htm)
  * [算法的复杂性](http://algorithm.myrice.com/algorithm/complexity/index.htm)
  * [算法设计策略 ](http://algorithm.myrice.com/algorithm/technique/index.htm)
  * [常用算法](http://algorithm.myrice.com/algorithm/commonalg/index.htm)

这里所有的算法都以一种类似Pascal语言的伪代码描述，请参阅[伪代码的使用](http://algorithm.myrice.com/algorithm/pseudocode.htm)。  
  
---|---  
  


|

   **新增内容**  
  
---|---  
  


[关于数论的算法----
数论基本知识](http://algorithm.myrice.com/algorithm/commonalg/numberic/basic_knowledge.htm)（May
6, 2001）  
[动态规划重新整理
](http://algorithm.myrice.com/algorithm/technique/dynamic_programming/index.htm)（January
15, 2001）  
[图的深度优先遍历
](http://algorithm.myrice.com/algorithm/commonalg/graph/traversal/dfs.htm)（January
21, 2001）

|

[图的广度优先遍历](http://algorithm.myrice.com/algorithm/commonalg/graph/traversal/bfs.htm)
（January 21, 2001）  
[图的拓扑排序
](http://algorithm.myrice.com/algorithm/commonalg/graph/connectivity/topo_sort.htm)（January
21, 2001）  
  
---|---  
  
# 算法 Algorithm

**算法**
是在有限步骤内求解某一问题所使用的一组定义明确的规则。通俗点说，就是计算机解题的过程。在这个过程中，无论是形成解题思路还是编写程序，都是在实施某种算法。前者是推理实现的算法，后者是操作实现的算法。

一个算法应该具有以下五个重要的特征：

1.      **有穷性：** 一个算法必须保证执行有限步之后结束；

2.      **确切性：** 算法的每一步骤必须有确切的定义；

3.      **输入：** 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件；

4.      **输出：** 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；

5.      **可行性：** 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。

|

**Did you know**  
  
---|---  
  
##  Algorithm 一词的由来  
  
[](http://www-groups.dcs.st-andrews.ac.uk/%7Ehistory/Mathematicians/Al-
Khwarizmi.html)[](http://www-groups.dcs.st-
andrews.ac.uk/%7Ehistory/Mathematicians/Al-
Khwarizmi.html)Algorithm(算法)一词本身就十分有趣。初看起来，这个词好像是某人打算要写"Logarithm"(对数)一词但却把头四个字母写的前后颠倒了。这个词一直到1957年之前在Webster's
New World
Dictionary(《韦氏新世界词典》)中还未出现，我们只能找到带有它的古代涵义的较老形式的"Algorism"(算术)，指的是用阿拉伯数字进行算术运算的过程。在中世纪时，珠算家用算盘进行计算，而算术家用算术进行计算。中世纪之后，对这个词的起源已经拿不准了，早期的语言学家试图推断它的来历，认为它是从把algiros(费力的)+arithmos(数字)组合起来派生而成的，但另一些人则不同意这种说法，认为这个词是从"喀斯迪尔国王Algor"派生而来的。最后，数学史学家发现了algorism(算术)一词的真实起源：它来源于著名的Persian
Textbook(《波斯教科书》)的作者的名字Abu Ja'far Mohammed ibn Musa al-Khowarizm
（约公元前825年）----从字面上看，这个名字的意思是"Ja'far 的父亲，Mohammed 和 Musa 的儿子，Khowarizm
的本地人"。Khowarizm 是前苏联XИBA(基发) 的小城镇 。Al-Khowarizm 写了著名的书Kitab al jabr w'al-
muqabala (《复原和化简的规则》)；另一个词，"algebra"(代数)，是从他的书的标题引出来的，尽管这本书实际上根本不是讲代数的。

逐渐地，"algorism"的形式和意义就变得面目全非了。如牛津英语字典所说明的，这个词是由于同arithmetic(算术)相混淆而形成的错拼词。由algorism又变成algorithm。一本早期的德文数学词典
Vollstandiges Mathematisches Lexicon (《数学大全辞典》) ，给出了Algorithmus
(算法)一词的如下定义："在这个名称之下，组合了四种类型的算术计算的概念，即加法、乘法、减法、除法"。拉顶短语 _algorithmus
infinitesimalis_ ( 无限小方法) ，在当时就用来表示Leibnitz(莱布尼兹)所发明的以无限小量进行计算的微积分方法。

1950年左右，algorithm一词经常地同欧几里德算法(Euclid's
algorithm)联系在一起。这个算法就是在欧几里德的《几何原本》(Euclid's Elements
,第VII卷，命题i和ii)中所阐述的求两个数的最大公约数的过程(即辗转相除法)。

左上方的图片是Abu Ja'far Mohammed ibn Musa al-Khowarizm的肖像，点击该图片可以看见关于他的更详细的资料。

#  

# 排序  
Sorting

**排序问题**
的输入是一个[线性表](http://algorithm.myrice.com/datastructure/index.html?basic/list/chapter1.htm)，该线性表的元素属于一个偏序集；要求对该线性表的元素做某种重排，使得线性表中除表尾外的每个元素都小于等于（或大于等于）它的后继。

设R为非空集合A上的二元关系，如果R满足 **自反性** (对于每一个x∈A，(x,x)∈R )， **反对称性**
((x,y)∈R∧(y,x)∈R→x=y )和 **传递性** ((x,y)∈R∧(y,x)∈R→(x,z)∈R)，则称R为A上的 **偏序关系**
，记作≤。如果(x,y)∈R，则记作x≤y，读作"x小于等于y"。存在偏序关系的集合A称为 **偏序集** 。

注意，这里的≤不是指数的大小，而是指在偏序关系中的顺序性。x≤y的含义是：按照这个序，x排在y前面。根据不同的偏序定义，≤有不同的解释。例如整除关系是偏序关系≤，3≤6的含义是3整除6。大于或等于关系也是偏序关系，针对这个关系5≤4是指在大于或等于关系中5排在4的前面，也就是说5比4大。

在实际应用中，经常遇到的偏序关系是定义在一个记录类型的数据集合上的。在该记录类型中有一个 **主键**
域key，key域的类型是某一个偏序集，记录的其他域称为卫星数据。比较线性表中的两个元素Li和Lj的大小，实际上是比较Li.key和Lj.key的大小（这种比较当然也是偏序集中的比较）。举例而言，某公司的数据库里记
录了员工的数据，每一项纪录包括姓名，编号，年龄，工资等几个域，如果以编号为key域对员工记录排序，则是将员工记录按照编号排序；如果以工资为key域对员工记录排序，则是将员工记录按照工资高低排序；如果以姓名为key域对员工记录排序，则是以员工姓名的汉语拼音按照字典顺序排序。

关于偏序集的具体概念和应用，请参见离散数学的相关资料。

如果一个排序算法利用输入的线性表在原地重排其中元素，而没有额外的内存开销，这种排序算法叫做 **原地置换排序算法** **(in place sort)**
；如果排序后并不改变表中相同的元素原来的相对位置，那么这种排序算法叫做 **稳定排序算法** **(stable sort)** 。

排序问题一般分为 **内排序** **( internal sorting )** 和 **外排序** **( external sorting )**
两类：

1.      [**内排序**](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/index.htm) ：待排序的表中记录个数较少，整个排序过程中所有的记录都可以保留在内存中；

2.      **外排序** ：待排序的记录个数足够多，以至于他们必须存储在磁带、磁盘上组成外部文件，排序过程中需要多次访问外存。



**内排序**

待排序的表中记录个数较少，整个排序过程中所有的记录都可以保留在内存中，这样的排序叫做内排序。

请参阅：

  * [排序问题的计算复杂性 ](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm)
  * [比较排序算法 ](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter2.htm)

    * [冒泡排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bubble_sort/bubble_sort.htm)
    * [选择排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/selection_sort/selection_sort.htm)
    * [插入排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/insertion_sort/insertion_sort.htm)
    * [快速排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm)
    * 合并排序
    * Shell排序
    * 堆排序
  * [线性时间排序算法 ](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter3.htm)
    * [计数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/counting_sort/counting_sort.htm)
    * [基数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/radix_sort/radix_sort.htm)
    * [桶排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bin_sort/bin_sort.htm)

##  

## 冒泡排序 Bubble Sort

最简单的排序方法是冒泡排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的"气泡"，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个"气泡"序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即"轻"的元素在下面，就交换它们的位置。显然，处理一遍之后，"最轻"的元素就浮到了最高位置；处理二遍之后，"次轻"的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是"最轻"元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。这个算法可实现如下。

    
    
    procedure Bubble_Sort(var L:List);
    
    
    var
    
    
    i,j:position;
    
    
    begin
    
    
    1 for i:=First(L) to Last(L)-1 do
    
    
    2  for j:=First(L) to Last(L)-i do
    
    
    3     if L[j]>L[j+1] then 
    
    
    4           swap(L[j],L[j+1]);   //交换L[j]和L[j+1]
    
    
    end;

上述算法将较大的元素看作较重的气泡，每次最大的元素沉到表尾。其中First(L)和Last(L)分别表示线性表L的第一个元素和最后一个元素的位置，swap(x,y)交换变量x,y的值。上述算法简单地将线性表的位置当作整数用for循环来处理，但实际上线性表可能用链表实现；而且上述算法将线性表元素的值当作其键值进行处理。不过这些并不影响表达该算法的基本思想。今后如果不加说明，所有的算法都用这种简化方式表达。

容易看出该算法总共进行了n(n-1)/2次比较。如果swap过程消耗的时间不多的话，主要时间消耗在比较上，因而时间复杂性为 _O_
(n2)。但是如果元素类型是一个很大的纪录，则Swap过程要消耗大量的时间，因此有必要分析swap执行的次数。

显然算法Bubble_Sort在最坏情况下调用n(n-1)/2次Swap过程。我们假设输入序列的分布是等可能的。考虑互逆的两个输入序列L1=k1,k2,..,kn和L2=kn,kn-1,..,k1。我们知道，如果ki>kj，且ki在表中排在kj前面，则在冒泡法排序时必定要将kj换到ki前面，即kj向前浮的过程中一定要穿过一次ki，这个过程要调用一次Swap。对于任意的两个元素ki和kj，不妨设ki>kj，或者在L1中ki排在kj前面，或者L2在中ki排在kj前面，两者必居其一。因此对于任意的两个元素ki和kj，在对L1和L2排序时，总共需要将这两个元素对调一次。n个元素中任取两个元素有Cn2
种取法，因此对于两个互逆序列进行排序，总共要调用Cn2
=n(n-1)/2次Swap，平均每个序列要调用n(n-1)/4次Swap。那么算法Bubble_Sort调用Swap的平均次数为n(n-1)/4。

可以对冒泡算法作一些改进，如果算法第二行的某次内循环没有进行元素交换，则说明排序工作已经完成，可以退出外循环。可以用一个布尔变量来记录内循环是否进行了记录交换，如果没有则终止外循环。

冒泡法的另一个改进版本是双向扫描冒泡法（Bi-Directional Bubble Sort）。设被排序的表中各元素键值序列为：

483 67 888 50 255 406 134 592 657 745 683

对该序列进行3次扫描后会发现，第3此扫描中最后一次交换的一对纪录是L[4]和L[5]：

50 67 255 134 | 406 483 592 657 683 745 888

显然，第3次扫描(i=3)结束后L[5]以后的序列都已经排好序了，所以下一次扫描不必到达Last(L)-i=11-4=7，即第2行的for
循环j不必到达7，只要到达4-1=3就可以了。按照这种思路，可以来回地进行扫描，即先从头扫到尾，再从尾扫到头。这样就得到双向冒泡排序算法：

    
    
    procedure Bi-Directional_Bubble_Sort(var L:List);
    
    
    var
    
    
    low,up,t,i:position;
    
    
    begin
    
    
    1  low:=First(L);up:=Last(L);
    
    
    2  while up>low do
    
    
        begin
    
    
    3     t:=low;
    
    
    4     for i:=low to up-1 do
    
    
    5       if L[i]>L[i+1] then
    
    
              begin
    
    
    6           swap(L[i],L[i+1]);
    
    
    7           t:=i;
    
    
              end;
    
    
    8     up:=t;
    
    
    9     for i:=up downto low+1 do
    
    
    10      if L[i]< L[i-1] then
    
    
              begin
    
    
    11          swap(L[i],L[i-1]);
    
    
    12          t:=i;
    
    
              end;
    
    
    13    low:=t;   
    
    
        end; 
    
    
    end;

算法利用两个变量low和up记录排序的区域L[low..up]，用变量t
记录最近一次交换纪录的位置，4-7行从前向后扫描，9-12行从后向前扫描，每次扫描以后利用t所记录的最后一次交换记录的位置，并不断地缩小需要排序的区间，直到该区间只剩下一个元素。

直观上来看，双向冒泡法先让重的气泡沉到底下，然后让轻的气泡浮上来，然后再让较大气泡沉下去，让较轻气泡浮上来，依次反复，直到排序结束。

双向冒泡排序法的性能分析比较复杂，目前暂缺，那位朋友知道请[告诉我](mailto:starfish.h@china.com)。

冒泡排序法和双向冒泡排序法是[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)，也是[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)，如果算法Bubble_Sort中第3行的比较条件L[j]>L[j+1]改为L[j]> **=** L[j+1]
，则不再是[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)。

## 选择排序 Selection Sort

选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。

选择排序算法可实现如下。

    
    
    procedure Selection_Sort(var L:List);
    
    
    var
    
    
    i,j,s:position;
    
    
    begin
    
    
    1  for i:=First(L) to Last(L)-1 do
    
    
        begin
    
    
    2       s:=i;
    
    
    3       for j:=i+1 to Last(L) do
    
    
    4         if L[j]< L[s] then 
    
    
    5                s:=j;             //记录L[i..n]中最小元素的位置
    
    
    6       swap(L[i],L[s]);       //交换L[i],L[s]
    
    
          end;  
    
    
    end;

算法Selection_Sort中里面的一个for循环需要进行n-i次比较，所以整个算法需要

次比较。

显而易见，算法Selection_Sort中共调用了n-1次swap过程。选择排序法是一个[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)，也是[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)。

##  

## 插入排序 Insertion Sort

插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i]又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤
L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j]
≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入。

图1 对4个元素进行插入排序

在下面的插入排序算法中，为了写程序方便我们可以引入一个哨兵元素L[0]，它小于L[1..n]中任一记录。所以，我们设元素的类型ElementType中有一个常量-∞，它比可能出现的任何记录都小。如果常量-∞不好事先确定，就必须在决定L[i]是否向前移动之前检查当前位置是否为1，若当前位置已经为1时就应结束第i遍的处理。另一个办法是在第i遍处理开始时，就将L[i]放入L[0]中，这样也可以保证在适当的时候结束第i遍处理。下面的算法中将对当前位置进行判断。

插入排序算法如下：

    
    
    procedure Selection_Sort(var L:List);
    
    
    var
    
    
    i,j:position;
    
    
    v:ElementType;
    
    
    begin
    
    
    1 for i:=First(L)+1 to Last(L) do
    
    
        begin
    
    
    2     v:=L[i];
    
    
    3     j:=i;
    
    
    4     while (j<>First(L))and(L[j-1]< v) do  //循环找到插入点
    
    
            begin
    
    
    5         L[j]:=L[j-1];  //移动元素
    
    
    6         j:=j-1;
    
    
            end;
    
    
    7     L[j]:=v;        //插入元素
    
    
        end;
    
    
    end;

下面考虑算法Insertion_Sort的复杂性。对于确定的i，内while循环的次数为 _O_ (i)，所以整个循环体内执行了∑ _O_ (i)= _O_
(∑i)，其中i从2到n。即比较次数为 _O_
(n2)。如果输入序列是从大到小排列的，那么内while循环次数为i-1次，所以整个循环体执行了∑(i-1)=n(n-1)/2次。由此可知，最坏情况下，Insertion_Sort要比较
_Ω_ (n2)次。

如果元素类型是一个很大的纪录，则算法第5行要消耗大量的时间，因此有必要分析移动元素的次数。经过分析可知，平均情况下第5行要执行n(n-1)/4次，分析方法与[冒泡排序的分析](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bubble_sort/bubble_sort.htm#swap)相同。

如果移动元素要消耗大量的时间，则可以[用链表来实现线性表](http://algorithm.myrice.com/datastructure/index.html?basic/list/chapter3_2.htm)，这样Insertion_Sort可以改写如下(当然前一个算法同样也适用于链表，只不过没下面这个好，但是下面算法这个比较复杂)：

注意：在下面的算法中链表L增加了一个哨兵单元，其中的元素为-∞，即线性表L的第一个元素是L^.next^

    
    
    procedure Selection_Sort_II(var L:PList);
    
    
    var
    
    
    i,j,tmp:Position;
    
    
    begin
    
    
    1  if L^.next=nil then exit; //如果链表L为空则直接退出
    
    
    2  i:=L^.next;  //i指向L的第一个元素，注意，L有一个哨兵元素，因此L^.next^才是L的第一个元素
    
    
    3  while i^.next<>nil do
    
    
         begin
    
    
    4      tmp:=i^.next;  //tmp指向L[i]的下一个位置
    
    
    5      j:=L;
    
    
    6      while (j<>i)and(tmp^.data>=j^.next^.data) do //从前向后找到tmp的位置，tmp应该插在j后面
    
    
    7      j:=j^.next;
    
    
    8      if j<>i then  //j=i说明不需要改变tmp的位置
    
    
             begin                              
    
    
    9          i^.next:=tmp^.next;  //将tmp从i后面摘除
    
    
    10         tmp^.next:=j^.next;  //在j后面插入tmp
    
    
    11         j^.next:=tmp;
    
    
             end
    
    
    12     else i:=i^.next;  //否则i指向下一个元素
    
    
        end;
    
    
    end;

上述改进算法主要是利用链表删除和插入元素方便的特性，对于数组则不适用。

插入排序法是一个[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)，也是一个[稳定排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)。插入法虽然在最坏情况下复杂性为 _θ_
(n2)，但是对于小规模输入来说，插入排序法是一个快速的[原地置换排序法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-
sort)。许多复杂的排序法，在规模较小的情况下，都使用插入排序法来进行排序，比如[快速排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm)和桶排序。

下面是一个Java Applet制作的插入排序演示程序。

** **

**快速排序 Quick Sort**

我们已经知道，[在决策树计算模型下，任何一个基于比较来确定两个元素相对位置的排序算法需要Ω(nlogn)计算时间](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm)。如果我们能设计一个需要
_O_ (n1ogn)时间的排序算法，则在渐近的意义上，这个排序算法就是最优的。许多排序算法都是追求这个目标。

下面介绍快速排序算法，它在平均情况下需要 _O_ (nlogn)时间。这个算法是由C.A.R.Hoare发明的。

**算法的基本思想** ****

快速排序的基本思想是基于[分治策略](http://algorithm.myrice.com/algorithm/technique/divide_and_conquer/index.htm)的。对于输入的子序列L[p..r]，如果规模足够小则直接进行排序，否则分三步处理：

  * 分解(Divide)：将输入的序列L[p..r]划分成两个非空子序列L[p..q]和L[q+1..r]，使L[p..q]中任一元素的值不大于L[q+1..r]中任一元素的值。
  * 递归求解(Conquer)：通过递归调用快速排序算法分别对L[p..q]和L[q+1..r]进行排序。
  * 合并(Merge)：由于对分解出的两个子序列的排序是就地进行的，所以在L[p..q]和L[q+1..r]都排好序后不需要执行任何计算L[p..r]就已排好序。

这个解决流程是符合[分治法的基本步骤](http://algorithm.myrice.com/algorithm/technique/divide_and_conquer/chapter3.htm)的。因此，快速排序法是分治法的经典应用实例之一。

**算法的实现** ****

算法Quick_Sort的实现：

**注意：**
下面的记号L[p..r]代表线性表L从位置p到位置r的元素的集合，但是L并不一定要用数组来实现，可以是用任何一种实现方法（比如说链表），这里L[p..r]只是一种记号。

procedure Quick_Sort(p,r:position;var L:List);

const

e=12;

var

q:position;

begin

1  if r-p<=e then Insertion_Sort(L,p,r)//若L[p..r]足够小则直接对L[p..r]进行插入排序

     else begin

2            q:=partition(p,r,L);//将L[p..r]分解为L[p..q]和L[q+1..r]两部分

3            Quick_Sort(p,q,L);  //递归排序L[p..q]

4            Quick_Sort(q+1,r,L);//递归排序L[q+1..r]  

          end;

end;

对线性表L[1..n]进行排序，只要调用Quick_Sort(1,n,L)就可以了。算法首先判断L[p..r]是否足够小，若足够小则直接对L[p..r]进行排序，Sort可以是任何一种简单的排序法，一般用[插入排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/insertion_sort/insertion_sort.htm)。这是因为，对于较小的表，快速排序中划分和递归的开销使得该算法的效率还不如其它的直接排序法好。至于规模多小才算足够小，并没有一定的标准，因为这跟生成的代码和执行代码的计算机有关，可以采取试验的方法确定这个规模阈值。经验表明，在大多数计算机上，取这个阈值为12较好，也就是说，当r-p<=e=12即L[p..r]的规模不大于12时，直接采用插入排序法对L[p..r]进行排序([参见
_Sorting and Searching Algorithms: A
Cookbook_](http://algorithm.myrice.com/resources/refrence/sorting_and_searching_algorithm_cookbook/s_man.htm))
。当然，比较方便的方法是取该阈值为1，当待排序的表只有一个元素时，根本不用排序(其实还剩两个元素时就已经在Partition函数中排好序了)，只要把第1行的if语句该为if
p=r then exit else ...。这就是通常教科书上看到的快速排序的形式。

**注意：**
算法Quick_Sort中变量q的值一定不能等于r，否则该过程会无限递归下去，永远不能结束。因此下文中在[partition函数](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm#Partition#Partition)里加了限制条件，避免q=r情况的出现。

算法Quick_Sort中调用了一个函数partition，该函数主要实现以下两个功能：

1.     在L[p..r]中选择一个支点元素pivot; 

2.     对L[p..r]中的元素进行整理，使得L[p..q]分为两部分L[p..q]和L[q+1..r]，并且L[p..q]中的每一个元素的值不大于pivot，L[q+1..r]中的每一个元素的值不小于pivot， **但是** **L[p..q]** **和** **L[q+1..r]** **中的元素并不要求排好序** 。

快速排序法改进性能的关键就在于上述的第二个功能，因为该功能并不要求L[p..q]和L[q+1..r]中的元素排好序。

函数partition可以实现如下。以下的实现方法是[原地置换](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-sort)的，当然也有不是原地置换的方法，实现起来较为简单，这里就不介绍了。

function partition(p,r:position;var L:List):position;

var

pivot:ElementType;

i,j:position;

begin

1  pivot:=Select_Pivot(p,r,L); //在L[p..r]中选择一个支点元素pivot

2  i:=p-1;

3  j:=r+1;

4  while true do

     begin

5      repeat j:=j-1 until L[j]<=pivot;  //移动左指针，注意这里不能用while循环

6      repeat i:=i+1 until L[i]>=pivot;  //移动右指针，注意这里不能用while循环

7      if i< j then swap(L[i],L[j])  //交换L[i]和L[j]

8              else if j<>r then return j        //返回j的值作为分割点

9                           else return j-1;     //返回j前一个位置作为分割点

     end;

end;

该算法的实现很精巧。其中，有一些细节需要注意。例如，算法中的位置i和j不会超出A[p..r]的位置界，并且该算法的循环不会出现死循环， **如果将两个**
**repeat** **语句换为** **while** **则要注意当** **L[i]=L[j]=pivot** **且** **i <j**
**时** **i** **和** **j** **的值都不再变化，会出现死循环。**

另外，最后一个if..then..语句很重要，因为如果pivot取的不好，使得Partition结束时j正好等于r，则如前所述，[算法Quick_Sort](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/quick_sort/quick_sort.htm#algorithm-
quick_sort#algorithm-quick_sort)会无限递归下去；因此必须判断j是否等于r，若j=r则返回j的前驱。

以上算法的一个执行实例如图1所示，其中pivot=L[p]=5：

图1 Partition过程的一个执行实例

Partition对L[p..r]进行划分时，以pivot作为划分的基准，然后分别从左、右两端开始，扩展两个区域L[p..i]和L[j..r]，使得L[p..i]中元素的值小于或等于pivot，而L[j..r]中元素的值大于或等于pivot。初始时i=p-1，且j=i+1，从而这两个区域是空的。在while循环体中，位置j逐渐减小，i逐渐增大，直到L[i]≥pivot≥L[j]。如果这两个不等式是严格的，则L[i]不会是左边区域的元素，而L[j]不会是右边区域的元素。此时若i在j之前，就应该交换L[i]与L[j]的位置，扩展左右两个区域。
while循环重复至i不再j之前时结束。这时L[p..r]己被划分成L[p..q]和L[q+1..r]，且满足L[p..q]中元素的值不大于L[q+1..r]中元素的值。在过程Partition结束时返回划分点q。

寻找支点元素select_pivot有多种实现方法，不同的实现方法会导致快速排序的不同性能。根据[分治法平衡子问题的思想](http://algorithm.myrice.com/algorithm/technique/divide_and_conquer/chapter3.htm#balance)，我们希望支点元素可以使L[p..r]尽量平均地分为两部分，但实际上这是很难做到的。下面我们给出几种寻找pivot的方法。

1.     选择L[p..r]的第一个元素L[p]的值作为pivot；

2.     选择L[p..r]的最后一个元素L[r]的值作为pivot；

3.     选择L[p..r]中间位置的元素L[m]的值作为pivot；

4.     选择L[p..r]的某一个随机位置上的值L[random(r-p)+p]的值作为pivot；

按照第4种方法随机选择pivot的快速排序法又称为 ** _随机化版本的快速排序法_**
，在下面的复杂性分析中我们将看到该方法具有平均情况下最好的性能，在实际应用中该方法的性能也是最好的。

下面是一个快速排序的Java
Applet演示程序，该程序使用第一种pivot选择法，即选L[p]为pivot，因此Partition过程作了一些简化，与我们这里的Partition过程实现方法不同，但功能相同。该程序是针对用数组实现的线性表，用C语言实现的。  
  
---  
  








**线性时间排序算法**

我们已经知道，[通过比较确定两个元素之间相对位置的比较排序算法计算时间复杂性下界为O(nlogn)](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm)，要想改进这个下界，就必须对输入的数据作某些限制。下面介绍的几种排序算法都可以在O(n)时间内对一个线性表进行排序，但是他们要求输入数据满足某种条件。

    * [计数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/counting_sort/counting_sort.htm)
    * [基数排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/radix_sort/radix_sort.htm)
    * [桶排序](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/bin_sort/bin_sort.htm)

**计数排序 Counting Sort**

计数排序是一个非[基于比较](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm#compsort)的线性时间排序算法。它对输入的数据有附加的限制条件：

1.      输入的[线性表](http://algorithm.myrice.com/datastructure/index.html?basic/list/chapter1.htm)的元素属于有限偏序集S；

2.      设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k= _O_ (n)。

在这两个条件下，计数排序的复杂性为 _O_ (n)。

计数排序算法的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。

假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k= _O_
(n)，S={S1,S2,..Sk}；则计数排序算法可以描述如下：

1.      扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；

2.      扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。

具体的实现如下。

**注意：**
在以下的讨论中，为了方便，我们假设[线性表是用数组来实现的](http://algorithm.myrice.com/datastructure/basic/list/chapter3_1.htm)，并且假设线性表的元素类型TElement为整型，其值在1..k之间，线性表的长度为n，且k=
_O_ (n)。这些假设对计数排序算法没有实质的影响，但是可以使以下介绍的算法看起来容易理解。

在下面的计数排序算法中，我们假设L为输入的长度为n的线性表，输出的排序结果存放在线性表R中。算法中还用到一个辅助表tmp用于对输入元素进行计数。

Type

TElement=1..k;

TList=array [1..maxlength] of TElement;

TPosition=integer;



procedure Counting_Sort(var L,R:TList);

var

i,j:integer;

tmp:TList;

begin

1 for i:=1 to k do tmp[i]:=0;

2 for j:=1 to n do inc(tmp[L[j]]);

   //执行完上面的循环后，tmp[i]的值是L中等于i的元素的个数

3 for i:=2 to k do tmp[i]:=tmp[i]+tmp[i-1];

   //执行完上面的循环后，tmp[i]的值是L中小于等于i的元素的个数

4 for j:=n downto 1 do  //注意这里的downto保证了排序的稳定性

   begin

5   R[tmp[L[j]]]:=L[j];//L[j]存放在输出数组R的第tmp[L[j]]个位置上

6   dec(tmp[L[j]]); //tmp[L[j]]表示L中剩余的元素中小于等于L[j]的元素的个数

   end;

end;

图1所示的是Counting_Sort作用于一个输入数组L[1..8]上的过程，其中L的每一个元素都是不大于k=6的正整数。

|  
  
---|---  
  
|  
  
|  
  
图1 计数排序算法演示

容易理解，算法的第(l)行是对数组tmp初始化。第(2)行检查每个输入元素。如果输入元素的键值为i，则tmp[i]增1。因此，在第(2)行执行结束后，tmp[i]中存放着值等于i的输入元素个数，i=1,2,..,k。算法的第(3)行，对每个i=1,2,..,i，统计值小于或等于i的输入元素个数。最后在(4)-(8)行中，将每个元素L[j]存放到输出数组R中相应的最终位置上。如果所有n个元素的值都不相同，则共有tmp[L[j]]个元素的键值小于或等于L[j]，而小于L[j]的元素有tmp[L[j]]-1个，因此tmp[L[j]]就是L[j]在输出数组R中的正确位置。当输入元素有相同的值时，每将一个L[j]存放到数组R时，tmp[L[j]]就减1，使下  
个值等于L[j]的元素存放在输出数组R中存放元素L[j]的前一个位置上。

计数排序算法的计算时间复杂性很容易分析。其中，第(1)行需要 _O_ (k)时间；第(2)行需要 _O_ (n)时间，第(3)行需要 _O_
(k)时间；第(4)-(8)行的for循环需要 _O_ (n)时间。这样，整个算法所需的计算间为 _O_ (n+k)。当k= _O_
(n)时，算法的计算时间复杂性为 _O_ (n)。

我们看到，计数排序算法没有用到元素间的比较，它利用元素的实际值来确定它们在输出数组中的位置。因此，计数排序算法不是一个[基于比较的排序算法](http://algorithm.myrice.com/algorithm/commonalg/sort/internal_sorting/chapter1.htm#compsort)，从而它的计算时间下界不再是Ω(nlogn)。另一方面，计数排序算法之所以能取得线性计算时间的上界是因为对元素的取值范围作了一定限制，即k=
_O_
(n)。如果k=n2,n3,..，就得不到线性时间的上界。此外，我们还看到，由于算法第4行使用了downto语句，经计数排序，输出序列中值相同的元素之间的相对次序与他们在输入序列中的相对次序相同，换句话说，计数排序算法是一个[稳定的排序算法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#stable-
sort)，但显然不是[原地置换排序算法](http://algorithm.myrice.com/algorithm/commonalg/sort/index.htm#in-
place-sort)。

**基数排序 Radix Sort**

基数排序是一种用在老式穿卡机上的算法。一张卡片有80列，每列可在12个位置中的任一处穿孔。排序器可被机械地"程序化"以检查每一迭卡片中的某一列，再根据穿孔的位置将它们分放12个盒子里。这样，操作员就可逐个地把它们收集起来。其中第一个位置穿孔的放在最上面，第二个位置穿孔的其次，等等。

对十进制数字来说，每列中只用到10个位置(另两个位置用于编码非数值字符)。一个d位数占用d个列。因为卡片排序器一次只能查看一个列，要对n张片上的d位数进行排序就要有个排序算法。

直感上，大家可能觉得应该按最重要的一位排序，然后对每个盒子中的数递归地排序，最后把结果合并起来。不幸的是，为排序每一个盒子中的数，10个盒子中的9个必须先放在一边，这个过程产生了许多要加以记录的中间卡片堆。

与人们的直感相反，基数排序是首先按最不重要的一位数字排序来解决卡片排序问题的。同样，把各堆卡片收集成一迭，其中0号盒子中的在1号盒子中的前面，后者又在2号盒子中的前面，等等。然后对整个一迭卡片按次重要位排序，并把结果同样地合并起来。重复这个过程，直到对所有的d位数字都进行了排序。所以，仅需要n遍就可将一迭卡片排好序。图1说明了基数排序作"一迭"7个三位数的过程。第一列为输入，其余各列示出了对各个数位进行逐次排序后表的情形。垂直向上的箭头指示了当前要被加以排序的数位。

图1 基数排序作用于一个由7个3位数组成的表上的过程

关于这个算法很重要的一点就是按位排序要稳定。由卡片排序器所故的排序是稳定的，但操作员在把卡片从盒子里拿出来时不能改变他们的次序，即使某一盒子中所有卡片在给定列上的穿孔位置都相同。

在一台典型的顺序随机存取计算机上，有时采用基数排序来对有多重域关键字的记录进行排序。例如，假设我们想根据三个关键字处、月和日来对日期排序。对这个问题，可以用带有比较函数的排序算法来做。给定两个日期，先比较年份，如果相同，再比较月份，如果再相同，再比较日。这儿我们可以采用另一个方法，即用一种稳定的排序方法对所给信息进行三次排序：先对日，其次对月，再对年。

基数排序的代码是很简单的、下面的过程假设长度为n的数组A中的每个元素都有d位数字，其中第1位是最低的，第d位是最高位。

procedure Radix_Sort(var L:List;d:integer);

var

i:integer;

begin

1  for i:=1 to d do

2     使用一种稳定的排序方法来对数组L按数字i进行排序;

end;

基数排序的正确性可以通过对正在被排序的列进行归纳而加以证明。对本算法时间代价的分析要取决于选择哪种稳定的中间排序算法。当每位数字都界于l到k之间，且k不太大时，可以选择计数排序。对n个d位数的每一遍处理的时间为O(n+k)，共有d遍，故基数排序的总时间为θ(dn+kd)。当d为常数，k=O(n)时，基数排序有线性运行时间。

某些计算机科学家倾向于把一个计算机字中所含位数看成是θ(lgn)。具体一点说，假设共有dlgn位数字，d为正常数。这样，如果待排序的每个数恰能容于一个计算机字内，我们就可以把它视为一个以n为基数的d位数。看一个例子：对一百万个64位数排序。通过把这些数当作是以216为基数的四位数，用基数排序四遍就可完成排序。这与一个典型的O(nlgn)比较排序相比要好得多，后者对每一个参加排序的数约要lgn=20次操作。但有一点不理想，即采用计数排序作为中间稳定排序算法的基数排序版本不能够进行原地置换排序，而很多O(nlgn)比较排序算法却是可以的。因此，当内存比较紧张时，一般来说选择快速排序更合适些。



**桶排序 Bin Sort**

平均情况下桶排序以线性时间运行。像计数排序一样，桶排序也对输入作了某种假设，
因而运行得很快。具体来说，计数排序假设输入是由一个小范围内的整数构成，而桶排序则 假设输入由一个随机过程产生，该过程将元素一致地分布在区间[0，1)上。

桶排序的思想就是把区间[0，1)划分成n个相同大小的子区间，或称桶，然后将n个输入数分布到各个桶中去。因为输入数均匀分布在[0，1)上，所以一般不会有很多数落在
一个桶中的情况。为得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列 出来即可。

在桶排序算法的代码中，假设输入是个含n个元素的数组A，且每个元素满足0≤
A[i]<1。另外还需要一个辅助数组B[O..n-1]来存放链表实现的桶，并假设可以用某种机制来维护这些表。

桶排序的算法如下，其中floor(x)是地板函数，表示不超过x的最大整数。

procedure Bin_Sort(var A:List);

begin

1  n:=length(A);

2  for i:=1 to n do

3    将A[i]插到表B[floor(n*A[i])]中;

4  for i:=0 to n-1 do

5    用插入排序对表B[i]进行排序;

6  将表B[0],B[1],...,B[n-1]按顺序合并;

end;



图1 Bin_Sort的操作

图1演示了桶排序作用于有10个数的输入数组上的操作过程。(a)输入数组A[1..10]。(b)在该算法的第5行后的有序表(桶)数组B[0..9]。桶i中存放了区间[i/10，(i+1)/10]上的值。排序输出由表B[O]、B[1]、...、B[9]的按序并置构成。

要说明这个算法能证确地工作，看两个元素A[i]和A[j]。如果它们落在同一个桶中，则它们在输出序列中有着正确的相对次序，因为它们所在的桶是采用插入排序的。现假设它们落到不同的桶中，设分别为B[i']和B[j']。不失一般性，假设i'<j'。在算法的代码中，当第6行中将B中的表并置起来时，桶B[i']中的元素先于桶B[j']中的元素，因而在输出序列中A[i]先于A[j]。现在要证鰽[i]≤A[j]。假设情况正好相反，我们有：

 i'=floor(n*A[i])≥floor(n*A[j])=j'

得矛盾 (因为i'<j')，从而证明桶排序能正确地工作。

现在来分析算法的运行时间。除第5行外，所有各行在最坏情况的时间都是O(n)。第5行中检查所有桶的时间是O(n)。分析中唯一有趣的部分就在于第5行中插人排序所花的时间。

为分析插人排序的时间代价，设ni为表示桶B[i]中元素个数的随机变量。因为插入排序以二次时间运行，故为排序桶B[i]中元素的期望时间为E[O(ni2)]=O(E[ni2])，对各个桶中的所有元素排序的总期望时间为：

(1)

为了求这个和式，要确定每个随机变量ni的分布。我们共有n个元素，n个桶。某个元素落到桶B[i]的概率为l/n，因为每个桶对应于区间[0，1)的l/n。这种情况与投球的例子很类似：有n个球
(元素)和n个盒子
(桶)，每次投球都是独立的，且以概率p=1/n落到任一桶中。这样，ni=k的概率就服从二项分布B(k;n,p)，其期望值为E[ni]=np=1，方差V[ni]=np(1-p)=1-1/n。对任意随机变量X，有:

(2)

将这个界用到(1)式上，得出桶排序中的插人排序的期望运行时间为O(n)。因而，整个桶排序的期望运行时间就是线性的。

下面的Java Applet程序演示了桶排序的基本思想。

很抱歉，您的浏览器不支持Java Applet或者没有打开Java Applet支持。

在该演示程序中，线性表的元素类型为整型，桶的标号为整数，算法将值为i的元素放入标号为i的桶中，再按照桶的标号的顺序将元素依次取出，就得到了最终的排序结果。



